What are Hooks?
-Hooks are a new feature addition in React version 16.8 which allows you to use React features without having to write a class.
-Hook do not work inside a class.

Why Hooks?

Reason 1
1.Understand how this keyword works in JavaScript.
2.Remember to bind event handlers in class components.
3.Classes do not minify very well and make hot reloading very unreliable.

Reason 2
1.There is no particular way to reuse stateful component logic.
2.HOC and render props patterns do address this problem.
3.Makes the code harder to follow.
4.There is need a to share stateful logic in a better way.

Hooks help us in this aspect by allowing us to reuse stateful component logic without changing the component hierarchy.

Reason 3

1.Create components for complex scenarios such as data fetching and subscribing to events.
2.Related code is not organized in one place. E.g. => Data fetching and event listeners.
3.Because of stateful logic - Cannot break components into smaller ones.

Hooks let you slit into one component into smaller functions based on what pieces are related.

useState Hook 
-import useState
-pass it in a default value
-assign return pair of value
-use them in a render function

Rules of Hooks
1."Only Call Hooks at the Top Level", Don't call Hooks inside loops, conditions, or nested functions.
2."Only Call Hooks from React Functions", Call them from within React functional components and not just any regular JS function.

With Previous State => setValue((prevValue) => prevValue - ...)
-A state variable can be string, number, boolean, object, or array
-In object, when assigning to the value just use the spread operator ...object, the thing that you want to change.
-In array, spread the array and append the array with the new value.

-The useState hook lets you add state to functional components
-With the useState hook, the state can be anything.
-The useState hook returns an array with 2 elements. 1. the current value 2. a state setter function.
-New state value depends on the previous state value? You can pass a function to the setter function.
-When dealing with objects or arrays, always make sure to spread your state variable and then call the setter function.

useEffect 
-The effect hook lets you perform side effects in functional components.
-It is a close replacement for the componentDidMount, componentDidUpdate, and componentWillMount.
-Passed in a function as a parameter and this function will execute after render of the component.
-useEffect has to be placed in the component because it can access the state and props without write any additional codes.

Conditionally run useEffect => for conditionally executing an effect, we passed in a second parameter. it is an array. In that array, we need to specify either prop or state,
that we need to watch for. 

-Effect will be called after render of the component unless you specify the dependency array. []

Run the effects only once. By simplifying the empty array. Only on initial render.

useEffect with cleanup => (componentWillUnMount). When you unmount the component, make sure you cancel all the subscriptions and listeners. Clean up after your component.
-Whatever you return in the function of useEffect, it is the cleanup function.
-When you want to execute some component cleanup code, you include it in the function and return the function from the function pass the useEffect. The clean code can be cancelling subscriptions, timers and removing eventListeners.

-If you think dependency array is a way to specify when you want to rerun the effect. <= This is gonna be a problem. Instead, dependency array should be thought of as a way to let React know about everything the effect must watch for changes.
-By announcing the prevState, you can keep track of the previous value. You can leave the empty array in the dependency array.

-Whenever you try to leave the dependency array empty, please make sure you really do not have any.
-Whenever you try to call function from useEffect, you can leave the function inside the useEffect. <= This way when you read through the useEffect, you are much more like to see a prop or state which have to specify as dependency.
-If you have multiple useEffect to run, make sure you separate them out rather than having all the code in a single useEffect.

Fetching Data with useEffect <= use axios in the useEffect. 
Fetching Data Individual with id <= /id 

Context
-Provides a way to pass data through the component tree without having to pass props down manually at every level.
1.create UserContext 
2.Provide a value to the context. Provider has to wrap the component.
3.Consume the value
-useContext hook only make the consumption of the context value simpler.
=> How? creating and providing the value remain the same. 1. import useContext from react, 2. import necessary context. 3. call the useContext function passing in the context as its arguments. useContext returns a context value. ***value ={''}

useReducer

-useReducer is a hook that is used for state management.
-It is an alternative to useState.

What is the different between useState and useReducer?
-useReducer is more primitive hook than useState.
-useReducer is related to reducer.
-useReducer is changing a state in React components.

reduce vs useReducer
-reduce in JS                                  | -useReducer in React
-array.reduce(reducer, initialValue)           | -useReducer(reducer, initialState)
-singleValue = reducer(accumulator, itemValue) | -newState = reducer(currentState, action)
-reduce method returns a single value          | -useReducer returns a pair of values. [newState, dispatch]

1.Define Initial State.
2.Define Reducer Method.
3.Import and call useReducer.
4.Get a hold of value to display in the JSX. We need a way to call the reducer with an appropriate action.
5.useReducer return a pair of value. The current state to the value. [value, dispatch]. This dispatch method allow us to execute the code corresponding to the particular action.

What is the advantage of this object complex initialState and object action?
-Concerning the value that we need to change. By making action as an object, we can use additional data in the reducer function.
-State as an object. Suppose we want to maintain one or more state, make a state in an object.  By using state as an object, we can track the states.

Multiple useReducers
-When dealing with multiple state variables that have the same state transition, it is a good idea to have a multiple useReducers function making use of same reducer function.
-It prevent from duplicating code.
-The value also independent.

useReducers with useContext
-useReducers - Local state management
-Share state between components - Global state management.
-Global state management can be created by combining both useReducers and useContext.

1. Create a useReducers.
2. Provide and consume the reducer context in the require component.
3. Provide a value with an object with a key

When should I use useReducer vs useState? 